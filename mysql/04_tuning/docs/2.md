# 기초
튜닝을 위한 기초를 알아봅니다.

## 선택도
테이블의 특정 열을 기준으로 해당 열의 WHERE 절에 따라 선택되는 데이터 비율을 의미합니다. 만약 열에 중복되는 데이터가 많으면 선택도가 높으며 조건절에 의해 대량의 데이터가 조회합니다. 즉, 낮은 선택도가 대용량 데이터에서 원하는 데이터만 골라낸다고 생각할 수 있고, 이러한 열은 인덱스를 생성할 때 주요 고려대상입니다.

## 카디널리티
중복을 제외한 유일한 데이터값의 수로 생각할 수 있습니다. 만약 특정 열에 중복값이 많으면 카디널리티는 낮고, 조회할 때 많은 데이터를 거르지 못하고 출력됩니다. 만약 중복값이 적으면 카디널리티는 높고, 소수의 데이터가 출력됩니다.

## 힌트
복잡한 쿼리에 대해서 DB 에 힌트를 전달하여 의도대로 동작하도록 도울 수 있습니다. 학생 테이블의 name 컬럼에 index01 인덱스가 있으면 인덱스를 사용하겠다는 힌트를 아래와 같이 DB 에 힌트를 줄 수 있습니다.
```mysql
# 일반적인 방법
SELECT * FROM student WHERE name = 'cola';

# 주석을 이용
SELECT * FROM student /*! USE INDEX (student_index01) */
WHERE name = 'cola';

# 쿼리로 작성
SELECT * FROM student 
USE INDEX (student_index01)
WHERE name = 'cola';
```

- STRAIGHT_JOIN: FROM 절에 작성된 테이블 순으로 조인을 유도하는 힌트
- USE INDEX: 특정 인덱스를 사용하도록 유도하는 힌트

명시적으로 힌트를 작성하여도 옵티마이저의 판단에 의해 힌트가 무시될 수 있습니다.

만약 name 인덱스를 삭제하게되면 위 쿼리는 에러를 발생시킵니다. 따라서 힌트가 작성된 SQL 문은 따로 관리되어야합니다.

## Metadata 란
데이터에 관한 구조화된 데이터로, 다른 데이터를 설명해주는 데이터입니다. Mysql 은 메타데이터를 묶어서 테이블을 만들고 테이블을 묶어 DB 를 만들었는데, 이 DB 가 information_schema 입니다. 얘는 Mysql 서버가 운영하는 모든 DB 에 대한 정보를 저장해놓은 DB 입니다.

```mysql
USE information_schema;
SHOW TABLES;
```

## 스토리지 엔진
InnoDB, Memory 등 스토리지 엔진은 사용자가 요청한 SQL 문을 토대로 DB 에 저장된 디스크나 메모리에서 필요한 데이터를 가져오고 Mysql 엔진으로 보내주는 역할을 수행합니다. 온라인상의 트랜잭션 발생으로 데이터를 처리하는 OLTP 환경에서는 일반적으로 InnoDB 엔진을 사용합니다.

```mysql
SELECT ENGINE, TRANSACTIONS COMMIT FROM information_schema.engines;
```

## Mysql 엔진
사용자가 요청한 sql 문의 문법 검사를 수행하고 sql 을 최소 단위로 분리하여 원하는 데이터를 빠르게 찾는 경로를 찾습니다. 또한, 스토리지 엔진에서 받은 데이터 중 불필요한 데이터를 제거 혹은 가공하는 역할을 합니다. 즉, SQL 문의 시작 및 마무리 단계에 관여하여 스토리지 엔진에서 필요한 데이터만을 가져오는 핵심 역할을 수행합니다.


## SQL 실행과정
파서, 전처리기, 옵티마이저, 엔진 실행기는 모두 Mysql 엔진에 포함되는 오브젝트입니다.

1. 사용자가 SQL 문 실행합니다.

2. 파서는 Mysql 이 이해할 수 있는 최소 단위로 구성요소를 분리하고 트리로 만듭니다. 이때 > 와 같은 기호 혹은 SQL 키워드로 분리하고 문법오류를 확인합니다.

3. 전처리기에서 생성된 트리 결과를 이용하여 이미 만들어진 테이블, 뷰 등으로 유효성을 검증합니다.

4. 옵티마이저는 트리를 구성하는 오브젝트의 데이터를 효율적으로 가져오기위해 데이터 검색 방법에 관한 실행계획을 수립합니다.

5. 엔진 실행기는 이전에 수립된 실행계획으로 스토리지 엔진을 호출하여 필요한 데이터를 가져오고, 불필요한 데이터를 필터링하여 사용자가 원하는 결과를 전달합니다.


## 인덱스
키값으로 실제 데이터 위치를 식별하고 데이터 접근 속도를 높이고자 생성되는 키 기준으로 정렬된 오브젝트입니다.

### 고유인덱스 (unique index)
인덱스를 구성하는 열들의 데이터가 유일하여 차례로 정렬되는 인덱스 열의 데이터는 서로 중복되지 않습니다. 만일 동일한 데이터가 생성되면 중복 체크 과정에서 에러가 발생합니다. 기본키와의 차이점은 기본키에는 NULL 이 들어갈 수 없지만 고유인덱스에는 들어갈 수 있습니다.

```mysql
ALTER TABLE student
ADD UNIQUE INDEX mobile_index (mobile);
```

### 비고유인덱스 (non-unique index)
일반적으로 언급되는 인덱스입니다. 데이터가 유일하지 않아, 데이터가 새로 insert 되어 인덱스가 재정렬되어도 인덱스 열의 중복체크를 하지 않습니다.

학생 테이블을 생성할 때, 만약 name 열을 기준으로 조회하는 경우가 자주 발생한다면 name 으로 비고유 인덱스를 생성할 수 있습니다.
```mysql
ALTER TABLE student
ADD INDEX name_index (name);
```

## 뷰
가상 테이블입니다. 뷰는 실제 테이블에서 조회하지 않아도 되는 데이터는 숨기고 필요한 데이터로만 뷰를 만들어 안전하게 운영하고 개발할 수 있는 환경을 제공합니다. 하나의 테이블을 참조하는 뷰를 생성하게 되면 해당 뷰와 테이블은 서로의 변경사항이 즉시 반영됩니다.
```mysql
CREATE VIEW student_view AS
SELECT id, name FROM student;
```
즉, 노출에 민감한 데이터에 대해서는 제약을 설정할 수 있는 보안성을 가지게 되어 뷰를 사용합니다.


## 조인
### 드라이빙 테이블, 드리븐 테이블
```mysql
SELECT 학생.학번, 학생.이, 비상연락망.관계, 비상연락망.연락처
    FROM 학생
    JOIN 비상연락망
    ON 학생.학변 = 비상연락망.학번
    WHERE 학생.학번 IN (1, 100);
```
위 쿼리는 먼저 학생 테이블에서 IN 조건에 만족하는 데이터를 찾고, 이걸로 비상연락망 테이블에서 검색합니다. 이렇게 분리된 테이블에서 JOIN 으로 데이터를 가져올 때 테이블에 접근하는 우선순위가 생기는데, 여기서는 먼저 접근하는 학생이 드라이빙 테이블이고 나중에 접근하는 비상연락망이 드리븐 테이블입니다.

드라이빙 테이블에서 많은 데이터가 반환되면 그만큼 드리븐 테이블에서도 접근하게 되므로 드라이빙 테이블을 결정하는 것이 중요합니다. 

따라서, 적은 데이터가 리턴될만한 것을 드라이빙 테이블로 선정하고, 조인 조건절의 열이 인덱스로 설정되도록 구성해야 합니다.

## 스캔
테이블 스캔은 인덱스를 거치지 않고 바로 디스크에 위치한 테이블 데이터에 접근, 인덱스 스캔은 인덱스로 테이블 데이터를 찾아갑니다.

### 테이블 풀 스캔
인덱스를 사용하지 않고 테이블의 처음부터 끝까지 훑어보는 방식입니다. WHERE 절 조건문을 기준으로 활용할 인덱스가 없거나 전체 데이터 대비 대량의 데이터가 필요할 때 많이 사용됩니다. 성능에서 부정적으로 해석되며, 인덱스 없이 사용하는 유일한 방식입니다.

### 인덱스 범위 스캔
인덱스를 범위 기준으로 스캔하여 스캔 결과로 테이블의 데이터를 찾아가는 방식입니다. BETWEEN ~ AND, <, >, LIKE 등 비교 연산 및 구문에 포함될 경우 인덱스 범위 스캔을 수행합니다. 좁은 범위에서는 매우 효율적이지만 넓을때는 비효율적입니다. (WHY??)

### 인덱스 풀 스캔
인덱스를 처음부터 끝까지 수행하는 방식입니다. 테이블에 접근하지 않고 인덱스로 구성된 열 정보만 요구하는 SQL 문에서 인덱스 풀 스캔이 수행됩니다. 테이블 풀 스캔보다는 성능이 좋지만 인덱스를 전부 검색하므로 검색 범위를 최대한 줄이는 방향으로 SQL 을 튜닝해야합니다.

### 인덱스 고유 스캔
기본키나 고유 인덱스로 테이블에 접근하는 방식으로, 가장 효율적입니다. WHERE 절에 = 조건으로 작성하며, 해당 조인 열이 기본키 혹은 고유 인덱스의 선두열로 설정되었을 때 활용합니다.

### 인덱스 루스스캔
인덱스의 필요한 부분들만 골라 스캔합니다. 인덱스 범위스캔처럼 넓은 범위에 전부 접근하는 것이 아닌, WHERE 을 기준으로 불필요한 데이터를 구분하여 해당 인덱스 키는 무시합니다. 보통 GROUP BY, MAX, MIN 이 포함되면 동작합니다.

### 인덱스 병합스캔


## 디스크 접근방식
데이터가 저장된 스토지리지의 페이지에 접근하여 데이터를 찾습니다. 페이지는 데이터를 검색하는 최소단위로, 페이지 단위로 데이터를 읽고 쓰기를 수행합니다.

### 시퀀셜 액세스
물리적으로 인접한 페이지를 차례대로 읽는 순차 접근 방식으로 테이블 풀 스캔에서 활용되며, 인접한 페이지를 여러개 읽는 다중 페이지 읽기 방식으로 수행됩니다.

### 랜덤 액세스
물리적으로 떨어진 페이지들에 임의로 접근하는 방식입니다. 다중 페이지 읽기가 불가능하여 데이터 접근 수행 시간이 오래걸립니다. 따라서 최소한의 페이지에 접근할 수 있도록 접근 범위를 줄이고 인덱스를 활용할 수 있도록 튜닝해야합니다.

## 조건유형
### 액세스 조건
WHERE 조건문을 기준으로 데이터가 저장된 디스크게 접근하는데, 이 때 맨 처음 디스크에서 데이터를 검색하는 조건을 의미하며, 디스크에 있는 데이터에 어떻게 접근할 것인지를 다루는만큼 튜닝에서 가장 중요합니다. 옵티마이저는 WHERE 절의 특정 조건문을 통해 소량의 데이터를 가져오고, 인덱스로 시간낭비를 줄이는 조건절을 선택하여 스토리지 엔진의 데이터에 접근하고 Mysql 엔진으로 데이터를 가져옵니다.
```mysql
SELECT * FROM student WHERE id = 1 AND name = 'cola';
```

위에서 만약 name 을 액세스 조건으로 삼아 데이터에 접근하게되면 인덱스를 활용하지 않아 많은 데이터에 접근하게 됩니다. 대신, id 열로 생성된 인덱스로 student 테이블의 일부 데이터에 접근하면 더 소량의 데이터에 접근합니다. 즉, id = 1 이 액세스 조건이 됩니다.

### 필터조건
액세스 조건을 통해 디스크에서 가져온 데이터에서 추가로 추출/가공/연산하는 조건입니다. 위 쿼리에서는 id=1 액세스 조건으로 가져온 데이터를 name='cola' 를 통해 필터링 작업을 합니다. 보통 필터 조건으로 제거될 데이터는 스토리지 엔진의 데이터에 접근하는 과정에서 같이 제외되는 편이 성능적으로 효율적이어서 필터조건에 따라 필터링할 데이터가 없으면 효율적인 SQL 문 입니다.
