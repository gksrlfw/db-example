# 튜닝예제
튜닝예제를 알아봅니다.

- 기본키를 변형하는 쿼리
- 사용하지 않는 함수를 포함하는 쿼리
- 형변환으로 인덱스를 활용하지 못하는 쿼리
- 열을 결합하여 사용하는 쿼리
- 습관적으로 중복을 제거하는 쿼리
- 다수 쿼리를 UNION 연산으로만 합치는 쿼리

- Todo


## 예제
### 1. 기본키를 변형하는 쿼리
사원 번호가 1100 으로 시작하면서 5자리인 사원의 정보를 모두 출력하시오

```mysql
EXPLAIN
SELECT *
FROM 사원
WHERE SUBSTRING(사원번호,1,4) = 1100
AND LENGTH(사원번호) = 5;

* 결과
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | 사원  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299157 |   100.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

위 쿼리는 key 가 null, type 이 ALL (테이블 풀 스캔), rows 도 출력 결과에 비해 많으므로 튜닝 대상입니다.

**WHERE 절에 기본키인 사원번호를 사용했지만 SUBSTRING, LENGTH 와 같이 가공하는 작업을 진행하여 기본키가 아닌 테이블 풀 스캔을 수행합니다.**

**이를 기본키 혹은 인덱스를 사용할 수 있도록 사원번호를 변형하지않고 사용해야합니다.**

```mysql
EXPLAIN
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 11000 AND 11009;

* 결과
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | 사원  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   10 |   100.00 | Using where |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

위 쿼리는 key 가 PRIMARY, type 은 특정범위만 스캔하여 range, rows 도 10개로 줄어 효율적으로 검색합니다.

### 2. 사용하지 않는 함수를 포함하는 쿼리
성별 기준으로 몇 명의 사원이 있는지 출력하시오
```mysql

# 내 방식
EXPLAIN
SELECT 성별, COUNT(*)
FROM 사원
WHERE 성별 = 'M'

UNION ALL

SELECT 성별, COUNT(*)
FROM 사원
WHERE 성별 = 'F';

* 결과
+----+-------------+--------+------------+------+---------------+--------------+---------+-------+--------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key          | key_len | ref   | rows   | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+--------------+---------+-------+--------+----------+-------------+
|  1 | PRIMARY     | 사원   | NULL       | ref  | I_성별_성     | I_성별_성    | 1       | const | 149556 |   100.00 | Using index |
|  2 | UNION       | 사원   | NULL       | ref  | I_성별_성     | I_성별_성    | 1       | const | 149556 |   100.00 | Using index |
+----+-------------+--------+------------+------+---------------+--------------+---------+-------+--------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)     
```
key 에 인덱스가 있으므로 Index 를 사용합니다.

```mysql

# 책 방식
EXPLAIN
SELECT IFNULL(성별,'NO DATA') AS 성별, COUNT(1) 건수
FROM 사원
GROUP BY IFNULL(성별,'NO DATA');

* 결과
+----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+------------------------------+
| id | select_type | table  | partitions | type  | possible_keys | key          | key_len | ref  | rows   | filtered | Extra                        |
+----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+------------------------------+
|  1 | SIMPLE      | 사원   | NULL       | index | I_성별_성     | I_성별_성    | 51      | NULL | 299113 |   100.00 | Using index; Using temporary |
+----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+------------------------------+
1 row in set, 1 warning (0.00 sec)
```
**key 에 인덱스가 있지만 extra 에 Using temporary 가 있으므로 임시 테이블을 생성합니다.**

**IFNULL 함수를 처리하기 위해 DB 내부적으로 별도 임시 테이블을 만들어서 NULL 값의 여부를 검사하고 있는데, 사실 성별은 NOT NULL 컬럼이므로 필요없는 함수힙니다.**

**따라서 IFNULL 함수는 제거해야합니다.**

```mysql
EXPLAIN
SELECT 성별, COUNT(1) 건수
FROM 사원
GROUP BY 성별;

* 결과
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+--------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | 사원  | NULL       | index | I_성별_성     | I_성별_성 | 51      | NULL | 299157 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

수행시간이 0.77 -> 0.1 로 줄게되고 Using temporary 는 없어지게됩니다.

### 3. 형변환으로 인덱스를 활용하지 못하는 쿼리
급여테이블에서 현재 유효한 급여 정보만 조회하고자 하는데, 사용여부 열의 값이 1인 데이터를 출력하시오

```mysql
EXPLAIN
SELECT 사용여부
FROM 급여
WHERE 사용여부 = 1;

* 결과
+----+-------------+-------+------------+-------+---------------+------------+---------+------+---------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows    | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+---------+----------+--------------------------+
|  1 | SIMPLE      | 급여  | NULL       | index | I_사용여부    | I_사용여부 | 4       | NULL | 2838731 |    10.00 | Using where; Using index |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+---------+----------+--------------------------+
1 row in set, 3 warnings (0.00 sec)
```

key 에 값이 있고 type 이 index 이므로 인덱스 풀 스캔이고, filtered 가 10% 입니다. mysql 엔진으로 가져온 데이터 중 10% 를 추출해서 최종 데이터를 출력함을 알 수 있습니다.
(Todo. 280만개 중 42842개인데 왜 10% 안자 모르겠다...)

**WHERE 절의 조건문으로 인덱스를 사용했음에도 인덱스 풀 스캔으로 동작하고 있습니다.**

**사용여부는 char 인데 사용여부 = 1 때문에 DBMS 내부의 묵시적 형변환이 발생하여 사용여부 인덱스를 활용하지 못하고 전체 데이터를 스캔하게 된 것입니다.**

```mysql
EXPLAIN
SELECT 사용여부
FROM 급여
WHERE 사용여부 = '1';

* 결과
+----+-------------+-------+------------+------+---------------+------------+---------+-------+-------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key        | key_len | ref   | rows  | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------------+---------+-------+-------+----------+-------------+
|  1 | SIMPLE      | 급여  | NULL       | ref  | I_사용여부    | I_사용여부 | 4       | const | 82824 |   100.00 | Using index |
+----+-------------+-------+------------+------+---------------+------------+---------+-------+-------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

**형변환을 제거하고 결과를 보면 동일하게 인덱스를 사용하고 있고, rows 를 통해 스토리지 엔진에 전달되어 필요한 데이터만 가져왔다는 것을 유추할 수 있습니다.**

### 4. 열을 결합하여 사용하는 쿼리
사원 테이블에서 성별과 1칸의 공백, 성의 값을 모두 결합한 결과가 'M Radwan' 인 데이터를 조회하시오
```
EXPLAIN
SELECT *
FROM 사원
WHERE CONCAT(성별,' ',성) = 'M Radwan';

* 결과
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | 사원  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299157 |   100.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```
type 이 ALL 로, 조건절로 데이터에 접근하지만 테이블 풀 스캔을 합니다. 

```mysql
SELECT CONCAT(성별,' ',성) '성별_성', COUNT(1)
FROM 사원
WHERE CONCAT(성별,' ',성) = 'M Radwan'
GROUP BY CONCAT(성별,' ',성)

UNION ALL

SELECT '전체 데이터', COUNT(1)
FROM 사원;

* 결과
+-------------+----------+
| 성별_성     | COUNT(1) |
+-------------+----------+
| M Radwan    |      102 |
| 전체 데이터 |   300024 |
+-------------+----------+
2 rows in set (2.50 sec)
```
위 쿼리로 전체 약 30만개 중 102개를 뽑아오는 쿼리라는 것을 확인할 수 있습니다. 

조건문이 = 이므로 인덱스로 빠르게 데이터를 조회할 수 있습니다. 

개선하려면 사원번호 기본키, 입사일자 인덱스, 성별 + 성 인덱스를 사용해야 합니다.

```mysql
EXPLAIN
SELECT *
FROM 사원
WHERE 성별 = 'M'
  AND 성 =  'Radwan';

* 결과
+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref         | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | 사원  | NULL       | ref  | I_성별_성     | I_성별_성 | 51      | const,const |  102 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```
인덱스 열들을 가공한 concat 을 제거하였고, 약 30만건에 접근하던 쿼리가 102건의 데이터만 접근하도록 액세스 범위가 줄었습니다.


### 5. 습관적으로 중복을 제거하는 쿼리
부서 관리자의 사원번호, 이름, 성, 부서번호 데이터를 중복 제거하여 조회하시오

```mysql
EXPLAIN
SELECT DISTINCT 사원.사원번호, 이름, 성, 부서번호
FROM 사원
JOIN 부서관리자
ON (사원.사원번호 = 부서관리자. 사원번호);

* 결과
+----+-------------+------------+------------+--------+---------------+------------+---------+----------------------------+------+----------+------------------------------+
| id | select_type | table      | partitions | type   | possible_keys | key        | key_len | ref                        | rows | filtered | Extra                        |
+----+-------------+------------+------------+--------+---------------+------------+---------+----------------------------+------+----------+------------------------------+
|  1 | SIMPLE      | 부서관리자 | NULL       | index  | PRIMARY       | I_부서번호 | 12      | NULL                       |   24 |   100.00 | Using index; Using temporary |
|  1 | SIMPLE      | 사원       | NULL       | eq_ref | PRIMARY       | PRIMARY    | 4       | tuning.부서관리자.사원번호 |    1 |   100.00 | NULL                         |
+----+-------------+------------+------------+--------+---------------+------------+---------+----------------------------+------+----------+------------------------------+
2 rows in set, 1 warning (0.00 sec)
```
부서관리자는 index 이므로 인덱스 풀 스캔, 사원은 eq_ref 로 사원번호 기본키로 한건의 데이터를 조회하는 방식으로 조인됩니다. 또한, DISTINCT 를 위해 별도 임시 테이블을 만듭니다.

```mysql
EXPLAIN
SELECT 사원.사원번호, 이름, 성, 부서번호
FROM 사원
JOIN 부서관리자
ON (사원.사원번호 = 부서관리자. 사원번호);

* 결과
+----+-------------+------------+------------+--------+---------------+------------+---------+----------------------------+------+----------+-------------+
| id | select_type | table      | partitions | type   | possible_keys | key        | key_len | ref                        | rows | filtered | Extra       |
+----+-------------+------------+------------+--------+---------------+------------+---------+----------------------------+------+----------+-------------+
|  1 | SIMPLE      | 부서관리자 | NULL       | index  | PRIMARY       | I_부서번호 | 12      | NULL                       |   24 |   100.00 | Using index |
|  1 | SIMPLE      | 사원       | NULL       | eq_ref | PRIMARY       | PRIMARY    | 4       | tuning.부서관리자.사원번호 |    1 |   100.00 | NULL        |
+----+-------------+------------+------------+--------+---------------+------------+---------+----------------------------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
```

DISTINCT 를 제거해 Using temporary 를 제거합니다.

### 6. 다수 쿼리를 UNION 연산으로만 합치는 쿼리
아래는 UNION 을 수행하는 쿼리입니다.
```
EXPLAIN
SELECT 'M' AS 성별, 사원번호
  FROM 사원 
 WHERE 성별 = 'M'
   AND 성 ='Baba'

 UNION

SELECT 'F', 사원번호
  FROM 사원
 WHERE 성별 = 'F'
   AND 성 = 'Baba';
   
* 결과
+------+--------------+------------+------------+------+---------------+-----------+---------+-------------+------+----------+-----------------+
| id   | select_type  | table      | partitions | type | possible_keys | key       | key_len | ref         | rows | filtered | Extra           |
+------+--------------+------------+------------+------+---------------+-----------+---------+-------------+------+----------+-----------------+
|  1   | PRIMARY      | 사원       | NULL       | ref  | I_성별_성     | I_성별_성 | 51      | const,const |  135 |   100.00 | Using index     |
|  2   | UNION        | 사원       | NULL       | ref  | I_성별_성     | I_성별_성 | 51      | const,const |   91 |   100.00 | Using index     |
| NULL | UNION RESULT | <union1,2> | NULL       | ALL  | NULL          | NULL      | NULL    | NULL        | NULL |     NULL | Using temporary |
+------+--------------+------------+------------+------+---------------+-----------+---------+-------------+------+----------+-----------------+
3 rows in set, 1 warning (0.00 sec)
```

id 가 1, 2 인 애들은 인덱스를 사용하고 있고, id 가 null 인 애는 1, 2인 행의 결과를 통합하여 중복을 제거하는 작업을 합니다.

이떄 Using temporary 를 통해 임시 테이블을 생성한다는 것을 알 수 있고 여기서 UNION 작업을 수행합니다. 

만일 메모리에 올리기 힘들만큼 데이터가 많다면 메모리가 아닌 디스크에 임시 파일을 생성하여 UNION 작업을 수행합니다.





# Todo

### 1. ref 가 정확히 무엇인지..?
* DISTINCT 는 나열된 열들을 정렬하고 중복된 데이터를 삭제하므로 정렬 작업이 포함됨을 인지해야합니다. 이미 정렬된 기본키나 인덱스를 활용하는 경우에는 정렬의 부담은 적어지게 됩니다.
**Todo. 3. 인덱스 풀 스캔에서 범위스캔으로 바꾸었을때 type 이 index -> ref 가 되었습니다. ref 가 정확히 어떤 경우에 되는지 다시 확인 필요**  

### 2.
**Todo. 4. * 가 아닌, 인덱스가 있는 컬럼만 가져오면 type 은 index, Extra 에 Using index 가 생깁니다. extra 는 모든 곳에 인덱스인 녀석만 사용하니까 이해가 되는데 type 은 왜 인덱스 풀 스캔으로 바뀌는지...???
(rows 를 보니 실제 인덱스를 탄것같진 않음..)**
```mysql
EXPLAIN
SELECT 사원번호, 성, 성별
FROM 사원
WHERE CONCAT(성별,' ',성) = 'M Radwan';

+----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+
| id | select_type | table  | partitions | type  | possible_keys | key          | key_len | ref  | rows   | filtered | Extra                    |
+----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+
|  1 | SIMPLE      | 사원   | NULL       | index | NULL          | I_성별_성    | 51      | NULL | 299113 |   100.00 | Using where; Using index |
+----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
```

### 3. tinyint 타입 비교...?
실제 쿼리 중 
```mysql
SELECT * 
FROM A
INNER JOIN B on B.a_id = A.id
INNER JOIN C on C.a_id = A.id
WHERE B.base_date < DATE("2022-01-01")
     AND A.is_used = true
```
base_date 는 인덱스가 있습니다.

위 쿼리의 explain 결과에서 A 테이블은 테이블 풀 스캔, base_date 가 인덱스를 타지 않았습니다.

여기서 A.is_used = true 를 A.is_used IS TRUE 로 변경하면 정상적으로 동작합니다.

tinyint(1) 값에는 0, 1, 2 ... 등 여러 숫자가 들어갈 수 있는데, = true 로 하면 1 만을 가져오고 is true 로 하면 전부 가져옵니다. (https://www.mysqltutorial.org/mysql-boolean/)

형변환이 일어나서 안되는 걸로 추측...?
