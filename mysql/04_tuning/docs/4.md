# 튜닝예제
튜닝예제를 알아봅니다.

- 기본키를 변형하는 쿼리
- 사용하지 않는 함수를 포함하는 쿼리
- 형변환으로 인덱스를 활용하지 못하는 쿼리
- 열을 결합하여 사용하는 쿼리
- 습관적으로 중복을 제거하는 쿼리
- 다수 쿼리를 UNION 연산으로만 합치는 쿼리
- 인덱스 고려 없이 열을 사용한 쿼리
- 엉뚱한 인덱스를 사용하는 쿼리

- Todo


## 예제
### 1. 기본키를 변형하는 쿼리
사원 번호가 1100 으로 시작하면서 5자리인 사원의 정보를 모두 출력하시오

```mysql
EXPLAIN
SELECT *
FROM 사원
WHERE SUBSTRING(사원번호,1,4) = 1100
AND LENGTH(사원번호) = 5;

* 결과
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | 사원  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299157 |   100.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

위 쿼리는 key 가 null, type 이 ALL (테이블 풀 스캔), rows 도 출력 결과에 비해 많으므로 튜닝 대상입니다.

**WHERE 절에 기본키인 사원번호를 사용했지만 SUBSTRING, LENGTH 와 같이 가공하는 작업을 진행하여 기본키가 아닌 테이블 풀 스캔을 수행합니다.**

**이를 기본키 혹은 인덱스를 사용할 수 있도록 사원번호를 변형하지않고 사용해야합니다.**

```mysql
EXPLAIN
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 11000 AND 11009;

* 결과
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | 사원  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |   10 |   100.00 | Using where |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

위 쿼리는 key 가 PRIMARY, type 은 특정범위만 스캔하여 range, rows 도 10개로 줄어 효율적으로 검색합니다.

### 2. 사용하지 않는 함수를 포함하는 쿼리
성별 기준으로 몇 명의 사원이 있는지 출력하시오
```mysql

# 내 방식
EXPLAIN
SELECT 성별, COUNT(*)
FROM 사원
WHERE 성별 = 'M'

UNION ALL

SELECT 성별, COUNT(*)
FROM 사원
WHERE 성별 = 'F';

* 결과
+----+-------------+--------+------------+------+---------------+--------------+---------+-------+--------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key          | key_len | ref   | rows   | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+--------------+---------+-------+--------+----------+-------------+
|  1 | PRIMARY     | 사원   | NULL       | ref  | I_성별_성     | I_성별_성    | 1       | const | 149556 |   100.00 | Using index |
|  2 | UNION       | 사원   | NULL       | ref  | I_성별_성     | I_성별_성    | 1       | const | 149556 |   100.00 | Using index |
+----+-------------+--------+------------+------+---------------+--------------+---------+-------+--------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)     
```
key 에 인덱스가 있으므로 Index 를 사용합니다.

```mysql

# 책 방식
EXPLAIN
SELECT IFNULL(성별,'NO DATA') AS 성별, COUNT(1) 건수
FROM 사원
GROUP BY IFNULL(성별,'NO DATA');

* 결과
+----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+------------------------------+
| id | select_type | table  | partitions | type  | possible_keys | key          | key_len | ref  | rows   | filtered | Extra                        |
+----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+------------------------------+
|  1 | SIMPLE      | 사원   | NULL       | index | I_성별_성     | I_성별_성    | 51      | NULL | 299113 |   100.00 | Using index; Using temporary |
+----+-------------+--------+------------+-------+---------------+--------------+---------+------+--------+----------+------------------------------+
1 row in set, 1 warning (0.00 sec)
```
**key 에 인덱스가 있지만 extra 에 Using temporary 가 있으므로 임시 테이블을 생성합니다.**

**IFNULL 함수를 처리하기 위해 DB 내부적으로 별도 임시 테이블을 만들어서 NULL 값의 여부를 검사하고 있는데, 사실 성별은 NOT NULL 컬럼이므로 필요없는 함수힙니다.**

**따라서 IFNULL 함수는 제거해야합니다.**

```mysql
EXPLAIN
SELECT 성별, COUNT(1) 건수
FROM 사원
GROUP BY 성별;

* 결과
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+--------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | 사원  | NULL       | index | I_성별_성     | I_성별_성 | 51      | NULL | 299157 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

수행시간이 0.77 -> 0.1 로 줄게되고 Using temporary 는 없어지게됩니다.

### 3. 형변환으로 인덱스를 활용하지 못하는 쿼리
급여테이블에서 현재 유효한 급여 정보만 조회하고자 하는데, 사용여부 열의 값이 1인 데이터를 출력하시오

```mysql
EXPLAIN
SELECT 사용여부
FROM 급여
WHERE 사용여부 = 1;

* 결과
+----+-------------+-------+------------+-------+---------------+------------+---------+------+---------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows    | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+---------+----------+--------------------------+
|  1 | SIMPLE      | 급여  | NULL       | index | I_사용여부    | I_사용여부 | 4       | NULL | 2838731 |    10.00 | Using where; Using index |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+---------+----------+--------------------------+
1 row in set, 3 warnings (0.00 sec)
```

key 에 값이 있고 type 이 index 이므로 인덱스 풀 스캔이고, filtered 가 10% 입니다. mysql 엔진으로 가져온 데이터 중 10% 를 추출해서 최종 데이터를 출력함을 알 수 있습니다.
(Todo. 280만개 중 42842개인데 왜 10% 안자 모르겠다...)

**WHERE 절의 조건문으로 인덱스를 사용했음에도 인덱스 풀 스캔으로 동작하고 있습니다.**

**사용여부는 char 인데 사용여부 = 1 때문에 DBMS 내부의 묵시적 형변환이 발생하여 사용여부 인덱스를 활용하지 못하고 전체 데이터를 스캔하게 된 것입니다.**

```mysql
EXPLAIN
SELECT 사용여부
FROM 급여
WHERE 사용여부 = '1';

* 결과
+----+-------------+-------+------------+------+---------------+------------+---------+-------+-------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key        | key_len | ref   | rows  | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------------+---------+-------+-------+----------+-------------+
|  1 | SIMPLE      | 급여  | NULL       | ref  | I_사용여부    | I_사용여부 | 4       | const | 82824 |   100.00 | Using index |
+----+-------------+-------+------------+------+---------------+------------+---------+-------+-------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

**형변환을 제거하고 결과를 보면 동일하게 인덱스를 사용하고 있고, rows 를 통해 스토리지 엔진에 전달되어 필요한 데이터만 가져왔다는 것을 유추할 수 있습니다.**

**type 은 index (인덱스 풀 스캔)에서 ref 로 변경되었습니다. ref 는 =, <, > 등의 연산자를 사용해 인덱스로 생성된 열을 비교할 때도 출력됩니다.**

### 4. 열을 결합하여 사용하는 쿼리
사원 테이블에서 성별과 1칸의 공백, 성의 값을 모두 결합한 결과가 'M Radwan' 인 데이터를 조회하시오
```
EXPLAIN
SELECT *
FROM 사원
WHERE CONCAT(성별,' ',성) = 'M Radwan';

* 결과
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | 사원  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299157 |   100.00 | Using where |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```
type 이 ALL 로, 조건절로 데이터에 접근하지만 테이블 풀 스캔을 합니다. 

```mysql
SELECT CONCAT(성별,' ',성) '성별_성', COUNT(1)
FROM 사원
WHERE CONCAT(성별,' ',성) = 'M Radwan'
GROUP BY CONCAT(성별,' ',성)

UNION ALL

SELECT '전체 데이터', COUNT(1)
FROM 사원;

* 결과
+-------------+----------+
| 성별_성     | COUNT(1) |
+-------------+----------+
| M Radwan    |      102 |
| 전체 데이터 |   300024 |
+-------------+----------+
2 rows in set (2.50 sec)
```
위 쿼리로 전체 약 30만개 중 102개를 뽑아오는 쿼리라는 것을 확인할 수 있습니다. 

조건문이 = 이므로 인덱스로 빠르게 데이터를 조회할 수 있습니다. 

개선하려면 사원번호 기본키, 입사일자 인덱스, 성별 + 성 인덱스를 사용해야 합니다.

```mysql
EXPLAIN
SELECT *
FROM 사원
WHERE 성별 = 'M'
  AND 성 =  'Radwan';

* 결과
+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref         | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | 사원  | NULL       | ref  | I_성별_성     | I_성별_성 | 51      | const,const |  102 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```
인덱스 열들을 가공한 concat 을 제거하였고, 약 30만건에 접근하던 쿼리가 102건의 데이터만 접근하도록 액세스 범위가 줄었습니다.


### 5. 습관적으로 중복을 제거하는 쿼리
부서 관리자의 사원번호, 이름, 성, 부서번호 데이터를 중복 제거하여 조회하시오

```mysql
EXPLAIN
SELECT DISTINCT 사원.사원번호, 이름, 성, 부서번호
FROM 사원
JOIN 부서관리자
ON (사원.사원번호 = 부서관리자. 사원번호);

* 결과
+----+-------------+------------+------------+--------+---------------+------------+---------+----------------------------+------+----------+------------------------------+
| id | select_type | table      | partitions | type   | possible_keys | key        | key_len | ref                        | rows | filtered | Extra                        |
+----+-------------+------------+------------+--------+---------------+------------+---------+----------------------------+------+----------+------------------------------+
|  1 | SIMPLE      | 부서관리자 | NULL       | index  | PRIMARY       | I_부서번호 | 12      | NULL                       |   24 |   100.00 | Using index; Using temporary |
|  1 | SIMPLE      | 사원       | NULL       | eq_ref | PRIMARY       | PRIMARY    | 4       | tuning.부서관리자.사원번호 |    1 |   100.00 | NULL                         |
+----+-------------+------------+------------+--------+---------------+------------+---------+----------------------------+------+----------+------------------------------+
2 rows in set, 1 warning (0.00 sec)
```
부서관리자는 index 이므로 인덱스 풀 스캔, 사원은 eq_ref 로 사원번호 기본키로 한건의 데이터를 조회하는 방식으로 조인됩니다. 또한, DISTINCT 를 위해 별도 임시 테이블을 만듭니다.

**참고로 DISTINCT 는 나열된 열들을 정렬하고 중복된 데이터를 삭제하므로 정렬 작업이 포함됨을 인지해야합니다. 물론 이미 정렬된 기본키나 인덱스를 활용하는 경우에는 정렬의 부담은 적어지게 됩니다.**

```mysql
EXPLAIN
SELECT 사원.사원번호, 이름, 성, 부서번호
FROM 사원
JOIN 부서관리자
ON (사원.사원번호 = 부서관리자. 사원번호);

* 결과
+----+-------------+------------+------------+--------+---------------+------------+---------+----------------------------+------+----------+-------------+
| id | select_type | table      | partitions | type   | possible_keys | key        | key_len | ref                        | rows | filtered | Extra       |
+----+-------------+------------+------------+--------+---------------+------------+---------+----------------------------+------+----------+-------------+
|  1 | SIMPLE      | 부서관리자 | NULL       | index  | PRIMARY       | I_부서번호 | 12      | NULL                       |   24 |   100.00 | Using index |
|  1 | SIMPLE      | 사원       | NULL       | eq_ref | PRIMARY       | PRIMARY    | 4       | tuning.부서관리자.사원번호 |    1 |   100.00 | NULL        |
+----+-------------+------------+------------+--------+---------------+------------+---------+----------------------------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
```

DISTINCT 를 제거해 Using temporary 를 제거합니다.

### 6. 다수 쿼리를 UNION 연산으로만 합치는 쿼리
아래는 UNION 을 수행하는 쿼리입니다.
```
EXPLAIN
SELECT 'M' AS 성별, 사원번호
  FROM 사원 
 WHERE 성별 = 'M'
   AND 성 ='Baba'

 UNION

SELECT 'F', 사원번호
  FROM 사원
 WHERE 성별 = 'F'
   AND 성 = 'Baba';
   
* 결과
+------+--------------+------------+------------+------+---------------+-----------+---------+-------------+------+----------+-----------------+
| id   | select_type  | table      | partitions | type | possible_keys | key       | key_len | ref         | rows | filtered | Extra           |
+------+--------------+------------+------------+------+---------------+-----------+---------+-------------+------+----------+-----------------+
|  1   | PRIMARY      | 사원       | NULL       | ref  | I_성별_성     | I_성별_성 | 51      | const,const |  135 |   100.00 | Using index     |
|  2   | UNION        | 사원       | NULL       | ref  | I_성별_성     | I_성별_성 | 51      | const,const |   91 |   100.00 | Using index     |
| NULL | UNION RESULT | <union1,2> | NULL       | ALL  | NULL          | NULL      | NULL    | NULL        | NULL |     NULL | Using temporary |
+------+--------------+------------+------------+------+---------------+-----------+---------+-------------+------+----------+-----------------+
3 rows in set, 1 warning (0.00 sec)
```

id 가 1, 2 인 애들은 인덱스를 사용하고 있고, id 가 null 인 애는 1, 2인 행의 결과를 통합하여 중복을 제거하는 작업을 합니다.

WHERE 절에서는 인덱스와 = 조건으로 데이터를 찾으므로 빠르게 조회합니다.

Using temporary 를 통해 임시 테이블을 생성한다는 것을 알 수 있고 여기서 UNION 작업을 수행합니다. 

만일 메모리에 올리기 힘들만큼 데이터가 많다면 메모리가 아닌 디스크에 임시 파일을 생성하여 UNION 작업을 수행합니다.
```mysql
EXPLAIN
SELECT 'M' as 성별, 사원번호
  FROM 사원 
 WHERE 성별 = 'M'
   AND 성 ='Baba'

 UNION ALL

SELECT 'F' as 성별, 사원번호
  FROM 사원
 WHERE 성별 = 'F'
   AND 성 ='Baba';
   
* 결과
+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------------+
| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref         | rows | filtered | Extra       |
+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------------+
|  1 | PRIMARY     | 사원  | NULL       | ref  | I_성별_성     | I_성별_성 | 51      | const,const |  135 |   100.00 | Using index |
|  2 | UNION       | 사원  | NULL       | ref  | I_성별_성     | I_성별_성 | 51      | const,const |   91 |   100.00 | Using index |
+----+-------------+-------+------------+------+---------------+-----------+---------+-------------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
```

UNION RESULT 행이 사라집니다.


### 7. 인덱스 고려 없이 열을 사용한 쿼리
성과 성별 순서로 그루핑하여 몇 건의 데이터가 있는지 구하시오.
```mysql
EXPLAIN
SELECT 성, 성별, COUNT(1) as 카운트
FROM 사원
GROUP BY 성, 성별;

* 결과
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+--------+----------+------------------------------+
| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows   | filtered | Extra                        |
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+--------+----------+------------------------------+
|  1 | SIMPLE      | 사원  | NULL       | index | I_성별_성     | I_성별_성 | 51      | NULL | 299157 |   100.00 | Using index; Using temporary |
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+--------+----------+------------------------------+
1 row in set, 1 warning (0.00 sec)
```

성별_성 인덱스를 사용하고, 인덱스로 가져온 데이터를 성과 성별 순으로 재정렬하기위해 임시 테이블을 만들고 성과 성별을 그루핑해 count 연산을 수행합니다.

사실 성별_성 인덱스는 성별, 성 순으로 생성된 오브젝트로, 셩별 기준으로 정렬된 후 성 기준으로 정렬되어 있습니다. 

이렇게 인덱스 순서대로 그루핑을 하면 따로 정렬을 위한 임시테이블을 생성하지 않습니다.

```mysql
EXPLAIN
SELECT 성, 성별, COUNT(1) as 카운트
FROM 사원
GROUP BY 성별, 성;

* 결과
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+--------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key       | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | 사원  | NULL       | index | I_성별_성     | I_성별_성 | 51      | NULL | 299157 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+-----------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

위 쿼리에서는 Using temporary 가 사라집니다.

### 8. 엉뚱한 인덱스를 사용하는 쿼리
사원의 입사일자가 1989 로 시작하면서 사원번호가 100000 을 초과하는 데이터를 조회하시오.

```mysql
EXPLAIN
SELECT 사원번호
FROM 사원
WHERE 입사일자 LIKE '1989%'
AND 사원번호 > 100000;

* 결과
+----+-------------+-------+------------+-------+--------------------+---------+---------+------+--------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys      | key     | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------+------------+-------+--------------------+---------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | 사원  | NULL       | range | PRIMARY,I_입사일자 | PRIMARY | 4       | NULL | 149578 |    11.11 | Using where |
+----+-------------+-------+------------+-------+--------------------+---------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

**위 쿼리는 기본키(PK)로 범위스캔(range) 을 수행합니다. 

스토리지 엔진에서 기본키를 구성하는 사원번호를 조건으로 데이터를 가져와서 mysql 엔진에서 입사일자 필터 조건으로 추출하여 filtered 가 11.11% 가 되었습니다.**

사원 전체 데이터는 300,024건, 입사일자가 1989년도인 데이터는 28394건, 사원번호가 100000보다 큰 데이터는 210,024건 있습니다. 사원번호가 100000번을 초과하는 데이터가 전체 데이터의 70% 나 차지하는 만큼,
스토리지 엔진에서 데이터에 접근할 때 사원번호 PK 로 액세스하는게 효율적인지 확인해야 합니다.
한편 입사일자로 검색했을때는 전체의 약 10%이므로 입사일자 인덱스를 액세스 조건으로 활용하는게 좋을지 확인해야합니다.


```mysql
EXPLAIN
SELECT 사원번호
FROM 사원 USE INDEX(I_입사일자)
WHERE 입사일자 LIKE '1989%'
AND 사원번호 > 100000;

* 결과
+----+-------------+-------+------------+-------+---------------+------------+---------+------+-------+----------+----------------------------------------+
| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows  | filtered | Extra                                  |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+-------+----------+----------------------------------------+
|  1 | SIMPLE      | 사원  | NULL       | range | I_입사일자    | I_입사일자 | 7       | NULL | 99709 |   100.00 | Using where; Using index for skip scan |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+-------+----------+----------------------------------------+
1 row in set, 1 warning (0.00 sec)
```

**위 처럼 입사일자 인덱스를 타도록 힌트를 설정하면(힌트를 추가하지 않으면 기본키를 사용하는 인덱스 스캔으로 수행합니다) 인덱스로 테이블을 스캔하지만 인덱스 루스 스캔 방식에 의해 인덱스를 스킵하는 오버헤드가 발생할 수 있습니다.**

```mysql
* SQL
EXPLAIN
SELECT 사원번호
FROM 사원
WHERE 입사일자 >= '1989-01-01' AND 입사일자 < '1990-01-01'
AND 사원번호 > 100000;

* 결과
+----+-------------+-------+------------+-------+--------------------+------------+---------+------+-------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys      | key        | key_len | ref  | rows  | filtered | Extra                    |
+----+-------------+-------+------------+-------+--------------------+------------+---------+------+-------+----------+--------------------------+
|  1 | SIMPLE      | 사원  | NULL       | range | PRIMARY,I_입사일자 | I_입사일자 | 7       | NULL | 49820 |    50.00 | Using where; Using index |
+----+-------------+-------+------------+-------+--------------------+------------+---------+------+-------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
```

**추가적으로 위 처럼 부분검색이 목적인 LIKE 절 대신 부등호 조건절이 우선하여 인덱스를 사용하므로 데이터 접근 범위를 줄일 수 있습니다.**

최종적으로 입사일자 인덱스로 범위스캔(range) 을 수행하고, Using index 를 통해 테이블에 접근하지 않고 인덱스로만 최종결과를 출력한다는 걸 알 수 있습니다.
스토리지 엔진으로부터 인덱스에 있는 데이터를 가져오고 mysql 엔진에서 사원번호에 대한 필터 조건으로 데이터를 추출합니다.

### 9. 동등조건으로 인덱스를 사용하는 쿼리
B 출입문으로 출입한 이력이 있는 정보를 모두 조회하시오.