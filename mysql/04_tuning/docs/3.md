# 실행계획 결과분석
실행계획 결과가 의미하는 것을 알아봅니다.


## id
실행 순서를 표시합니다. join 일 경우에는 같은 ID 로 표시되고, 숫자가 작을수록 먼저수행됩니다.

## select_type
쿼리를 구성하는 SELECT 문의 유형을 출력합니다.

### SIMPLE
UNION 혹은 내부 쿼리가 없는 SELECT 문입니다.
```mysql
EXPLAIN 
SELECT * FROM 사원 WHERE 사원번호 = 100000;

* 결과
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | 사원  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+

```

```mysql
EXPLAIN
SELECT 사원.사원번호, 사원.이름, 사원.성, 급여.연봉
FROM 사원,
     (SELECT 사원번호, 연봉   # 서브쿼리가 아닙니다.
      FROM 급여
      WHERE 연봉 > 80000) AS 급여
WHERE 사원.사원번호 = 급여.사원번호
AND 사원.사원번호 BETWEEN 10001 AND 10010;

* 결과
+----+-------------+-------+------------+-------+---------------+---------+---------+----------------------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref                  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+----------------------+------+----------+-------------+
|  1 | SIMPLE      | 사원  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL                 |   10 |   100.00 | Using where |
|  1 | SIMPLE      | 급여  | NULL       | ref   | PRIMARY       | PRIMARY | 4       | tuning.사원.사원번호 |    9 |    33.33 | Using where |
+----+-------------+-------+------------+-------+---------------+---------+---------+----------------------+------+----------+-------------+

```

### PRIMARY
서브쿼리가 포함된 쿼리문이 있을 때, 첫번째 SELECT 문에 해당하는 구문에 표시됩니다. 즉, 서브쿼리를 감싸는 외부쿼리 혹은 UNION 이 포함된 쿼리문에서 첫번째로 SELECT 키워드가 작성된 구문입니다.

아래에서는 외부쿼리의 사원 테이블을 먼저 접근하여 PRIMARY 가 됩니다.
```mysql
EXPLAIN
SELECT 사원.사원번호, 사원.이름, 사원.성,
       (SELECT MAX(부서번호) 
        FROM 부서사원_매핑 as 매핑 WHERE 매핑.사원번호 = 사원.사원번호) 카운트
FROM 사원
WHERE 사원.사원번호 = 100001;

* 결과
+----+--------------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+------------------------------+
| id | select_type        | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra                        |
+----+--------------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+------------------------------+
|  1 | PRIMARY            | 사원  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL                         |
|  2 | DEPENDENT SUBQUERY | NULL  | NULL       | NULL  | NULL          | NULL    | NULL    | NULL  | NULL |     NULL | Select tables optimized away |
+----+--------------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+------------------------------+
```

아래에서는 사원1 테이블을 먼저 접근하여 PRIMARY 가 됩니다.
```mysql
EXPLAIN
SELECT 사원1.사원번호, 사원1.이름, 사원1.성
FROM 사원 as 사원1
WHERE 사원1.사원번호 = 100001

UNION ALL

SELECT 사원2.사원번호, 사원2.이름
FROM 사원 as 사원2
WHERE 사원2.사원번호 = 100002;

* 결과
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | PRIMARY     | 사원1 | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
|  2 | UNION       | 사원2 | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
2 rows in set, 1 warning (0.00 sec)
```

### SUBQUERY
독립적으로 수행되는 서브쿼리입니다. SELECT 절의 스칼라 서브쿼리와 WHERE 절의 중첩 서브쿼리일 경우에 해당됩니다.
```mysql
EXPLAIN
SELECT (SELECT COUNT(*)
        FROM 부서사원_매핑 as 매핑
        ) as 카운트,
       (SELECT MAX(연봉)
        FROM 급여
        ) as 급여;

* 결과
+----+-------------+-------+------------+-------+---------------+------------+---------+------+---------+----------+----------------+
| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows    | filtered | Extra          |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+---------+----------+----------------+
|  1 | PRIMARY     | NULL  | NULL       | NULL  | NULL          | NULL       | NULL    | NULL |    NULL |     NULL | No tables used |
|  3 | SUBQUERY    | 급여  | NULL       | ALL   | NULL          | NULL       | NULL    | NULL | 2838731 |   100.00 | NULL           |
|  2 | SUBQUERY    | 매핑  | NULL       | index | NULL          | I_부서번호 | 12      | NULL |  331143 |   100.00 | Using index    |
+----+-------------+-------+------------+-------+---------------+------------+---------+------+---------+----------+----------------+
3 rows in set, 1 warning (0.00 sec)
```

### DERIVED
FROM 절에 작성된 서브쿼리 즉, 임시 테이블인 인라인 뷰를 의미합니다.
```mysql
EXPLAIN
SELECT 사원.사원번호, 급여.연봉
FROM 사원,
       (SELECT 사원번호, MAX(연봉) as 연봉
        FROM 급여
        WHERE 사원번호 BETWEEN 10001 AND 20000 
        GROUP BY 사원번호) as 급여
WHERE 사원.사원번호 = 급여.사원번호;

* 결과
+----+-------------+------------+------------+--------+---------------+---------+---------+-------+--------+----------+-------------+
| id | select_type | table      | partitions | type   | possible_keys | key     | key_len | ref   | rows   | filtered | Extra       |
+----+-------------+------------+------------+--------+---------------+---------+---------+-------+--------+----------+-------------+
|  1 | PRIMARY     | <derived2> | NULL       | system | NULL          | NULL    | NULL    | NULL  |      1 |   100.00 | NULL        |
|  1 | PRIMARY     | 사원       | NULL       | const  | PRIMARY       | PRIMARY | 4       | const |      1 |   100.00 | Using index |
|  2 | DERIVED     | 급여       | NULL       | range  | PRIMARY       | PRIMARY | 4       | NULL  | 184756 |   100.00 | Using where |
+----+-------------+------------+------------+--------+---------------+---------+---------+-------+--------+----------+-------------+
3 rows in set, 1 warning (0.05 sec)
```

### UNION
UNION 및 UNION ALL 구문으로 합쳐진 SELECT 문에서 첫번쨰 이후의 SELECT 구문을 의미합니다.
```mysql
EXPLAIN
SELECT 'M' as 성별, MAX(입사일자) as 입사일자
FROM 사원 as 사원1
WHERE 성별 = 'M'

UNION ALL

SELECT 'F' as 성별, MIN(입사일자) as 입사일자
FROM 사원 as 사원2
WHERE 성별 = 'F';

* 결과
+----+-------------+-------+------------+------+---------------+-----------+---------+-------+--------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key       | key_len | ref   | rows   | filtered | Extra |
+----+-------------+-------+------------+------+---------------+-----------+---------+-------+--------+----------+-------+
|  1 | PRIMARY     | 사원1 | NULL       | ref  | I_성별_성     | I_성별_성 | 1       | const | 149578 |   100.00 | NULL  |
|  2 | UNION       | 사원2 | NULL       | ref  | I_성별_성     | I_성별_성 | 1       | const | 149578 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+-----------+---------+-------+--------+----------+-------+
2 rows in set, 1 warning (0.01 sec)
```

### UNION RESULT
UNION 일 때입니다. UNION 은 출력값이 유니크값이므로 각 SELECT 절에서 데이터를 가져와 정렬하여 중복 체크하는 과정이 있습니다.
```mysql
EXPLAIN
SELECT 사원_통합.* 
FROM ( 
      SELECT MAX(입사일자) as 입사일자
      FROM 사원 as 사원1
      WHERE 성별 = 'M' 
      
	  UNION 

      SELECT MIN(입사일자) as 입사일자
      FROM 사원 as 사원2
      WHERE 성별 = 'M' 
    ) as 사원_통합; 

* 결과
+------+--------------+------------+------------+------+---------------+-----------+---------+-------+----`----+----------+-----------------+
| id   | select_type  | table      | partitions | type | possible_keys | key       | key_len | ref   | rows   | filtered | Extra           |
+------+--------------+------------+------------+------+---------------+-----------+---------+-------+--------+----------+-----------------+
|  1   | PRIMARY      | <derived2> | NULL       | ALL  | NULL          | NULL      | NULL    | NULL  |      2 |   100.00 | NULL            |
|  2   | DERIVED      | 사원1      | NULL       | ref  | I_성별_성     | I_성별_성 | 1       | const | 149578 |   100.00 | NULL            |
|  3   | UNION        | 사원2      | NULL       | ref  | I_성별_성     | I_성별_성 | 1       | const | 149578 |   100.00 | NULL            |
| NULL | UNION RESULT | <union2,3> | NULL       | ALL  | NULL          | NULL      | NULL    | NULL  |   NULL |     NULL | Using temporary |
+------+--------------+------------+------------+------+---------------+-----------+---------+-------+--------+----------+-----------------+
4 rows in set, 1 warning (0.00 sec)
```

### DEPENDENT SUBQUERY


## table
테이블 명을 표시합니다. 서브쿼리 혹은 임시 테이블의 경우 subquery 또는 derived 로 출력합니다.

## partitions
## type
테이블을 풀스캔할지, 인덱스를 이용할지 등 테이블의 데이터를 어떻게 찾을지에 관한 정보입니다.

### system
테이블에 데이터가 없거나 하나만 있는 경우로, 성능상 최상의 type 입니다.

### const
고유 인덱스 혹은 기본키를 활용한 조회 등 조회되는 데이터가 한 건일때 출력되며 성능상 유리합니다.
```mysql
EXPLAIN
SELECT *
FROM 사원
WHERE 사원번호 = 10001;

* 결과
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | 사원  | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

### eq_ref
조인이 수행될때 드리븐 테이블의 데이터에 접근하며 고유 인덱스 혹은 기본키로 한 건의 데이터를 조회하는 방식으로, 드라이빙 테이블과의 조인 키가 드리븐 테이블에 유일하므로 조인이 수행될 때 성능상 가장 좋습니다.
```mysql
EXPLAIN
SELECT 매핑.사원번호, 부서.부서번호, 부서.부서명
FROM 부서사원_매핑 as 매핑,
     부서
WHERE 매핑.부서번호 = 부서.부서번호
AND 매핑.사원번호 BETWEEN 100001 AND 100010;

* 결과
+----+-------------+-------+------------+--------+--------------------+---------+---------+----------------------+------+----------+--------------------------+
| id | select_type | table | partitions | type   | possible_keys      | key     | key_len | ref                  | rows | filtered | Extra                    |
+----+-------------+-------+------------+--------+--------------------+---------+---------+----------------------+------+----------+--------------------------+
|  1 | SIMPLE      | 매핑  | NULL       | range  | PRIMARY,I_부서번호 | PRIMARY | 4       | NULL                 |   12 |   100.00 | Using where; Using index |
|  1 | SIMPLE      | 부서  | NULL       | eq_ref | PRIMARY            | PRIMARY | 12      | tuning.매핑.부서번호 |    1 |   100.00 | NULL                     |
+----+-------------+-------+------------+--------+--------------------+---------+---------+----------------------+------+----------+--------------------------+
2 rows in set, 1 warning (0.01 sec)
```
type 이 eq_ref 이므로 조인 시 기본키 혹은 고유 인덱스로 한 건의 데이터씩만 검색하는 것을 알 수 있습니다. 

* 드라이빙 테이블을 기준으로 생각해야합니다! 결과만 보고나서, 부서를 기준으로 생각하면 매핑 테이블은 여러개가 될 수 있어서 ref 이지만 매핑 테이블이 드라이빙 테이블이므로 eq_ref 입니다!

### ref
조인 시, 드리븐 테이블의 데이터 접근 범위가 2개 이상일 경우입니다. 즉, 드라이빙 테이블과 1:N 관계가 되어 드라이빙 테이블 1개에 드리븐 테이블 2개 이상의 데이터가 존재하게 됩니다.

이떄, 기본키 혹은 고유인덱스를 사용하면 2개 이상의 데이터가 검색되거나 유일성이 없는 비고유 인덱스를 사용합니다. 드리븐의 데이터양이 많지 않을때는 괜찮지만 많으면 접근해야할 데이터 범위가 넓어져서 성능이 저하될 수 있습니다.

또는, =, <, > 등의 연산자를 사용해 인덱스로 생성된 열을 비교할 때도 출력됩니다.

```mysql
EXPLAIN
SELECT 사원.사원번호, 직급.직급명
FROM 사원, 직급
WHERE 사원.사원번호 = 직급.사원번호
AND 사원.사원번호 BETWEEN 10001 AND 10100;

* 결과
+----+-------------+-------+------------+-------+---------------+---------+---------+----------------------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref                  | rows | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+---------+---------+----------------------+------+----------+--------------------------+
|  1 | SIMPLE      | 사원  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL                 |  100 |   100.00 | Using where; Using index |
|  1 | SIMPLE      | 직급  | NULL       | ref   | PRIMARY       | PRIMARY | 4       | tuning.사원.사원번호 |    1 |   100.00 | Using index              |
+----+-------------+-------+------------+-------+---------------+---------+---------+----------------------+------+----------+--------------------------+
2 rows in set, 1 warning (0.00 sec)
```
사원 한 개로 여러개의 직급 데이터가 조회될 수 있어서, 드라이빙인 사원의 사원번호를 조인키로 직급 데이터에 접근하지만 사원번호당 다수의 직급데이터가 조회될 수 있다고 짐작할 수 있습니다.

```mysql
EXPLAIN
SELECT *
FROM 사원
WHERE 입사일자 = '1985-11-21';

* 결과
+----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | 사원  | NULL       | ref  | I_입사일자    | I_입사일자 | 3       | const |  119 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```
입사일자는 인덱스로 생성된 열로, 비교연산을 수행하여 ref 가 출렵됩니다.

### ref_or_null
ref 와 유사하지만 IS NULL 구문에 대해 인덱스를 활용하도록 최적화된 방식입니다. NULL 에 대해서도 인덱스로 검색할 수 있는데, 이때 NULL 은 가장 앞에 정렬됩니다. 

테이블에 검색할 NULL 양이 적다면 ref_of_null 방식이 효율적이고, 아니라면 튜닝의 대상이 됩니다.
```mysql
EXPLAIN
SELECT *
FROM 사원출입기록
WHERE 출입문 IS NULL
OR 출입문 = 'A';

* 결과
+----+-------------+--------------+------------+-------------+---------------+----------+---------+-------+--------+----------+-----------------------+
| id | select_type | table        | partitions | type        | possible_keys | key      | key_len | ref   | rows   | filtered | Extra                 |
+----+-------------+--------------+------------+-------------+---------------+----------+---------+-------+--------+----------+-----------------------+
|  1 | SIMPLE      | 사원출입기록 | NULL       | ref_or_null | I_출입문      | I_출입문 | 4       | const | 329468 |   100.00 | Using index condition |
+----+-------------+--------------+------------+-------------+---------------+----------+---------+-------+--------+----------+-----------------------+
1 row in set, 1 warning (0.01 sec)
```

### range
테이블 내의 연속된 데이터 범위를 조회하는 유형으로, =, <>, <, <=, >, >=, IS NULL, <=>, between, in 을 통해 범위 스캔을 수행하는 방식입니다.
스캔 범위가 넓으면 성능 저하의 요인이 될 수 있습니다.
```mysql
EXPLAIN
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 10001 AND 100000;

* 결과
+----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | 사원  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL | 149578 |   100.00 | Using where |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.01 sec)
```

### fulltext
텍스트 검색을 빠르게 하려고 전문 인덱스 (full text index) 로 데이터에 접근하는 방식입니다.

### index_merge
https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jblimn&logNo=110045226961

특정 테이블에 생성된 두 개 이상의 인덱스가 병합되어 동시에 적용되는, 즉 결합된 인덱스들이 동시에 사용되는 유형입니다.
```mysql
EXPLAIN
SELECT * 
FROM 사원 
WHERE 사원번호 BETWEEN 10001 AND 100000 
AND 입사일자 = '1985-11-21'; 

* 결과
+----+-------------+-------+------------+-------------+--------------------+--------------------+---------+------+------+----------+--------------------------------------------------+
| id | select_type | table | partitions | type        | possible_keys      | key                | key_len | ref  | rows | filtered | Extra                                            |
+----+-------------+-------+------------+-------------+--------------------+--------------------+---------+------+------+----------+--------------------------------------------------+
|  1 | SIMPLE      | 사원  | NULL       | index_merge | PRIMARY,I_입사일자 | I_입사일자,PRIMARY | 7,4     | NULL |   15 |   100.00 | Using intersect(I_입사일자,PRIMARY); Using where |
+----+-------------+-------+------------+-------------+--------------------+--------------------+---------+------+------+----------+--------------------------------------------------+
1 row in set, 1 warning (0.00 sec)
```
index_merge 를 보고 입사일자열에 대한 인덱스와 PK 를 통합해서 사용한다고 예측할 수 있습니다.

### index
물리적인 인덱스 블록을 처음부터 끝까지 보는 인덱스 풀 스캔을 의미합니다. 인덱스를 보는것을 제외하면 ALL 과 유사합니다.
보통 테이블보다 인덱스의 크기가 작으므로 테이블 풀 스캔보다 빠를 가능성이 높습니다.
```mysql
EXPLAIN
SELECT 사원번호
FROM 직급
WHERE 직급명 = 'Manager';

* 결과
+----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows   | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+--------------------------+
|  1 | SIMPLE      | 직급  | NULL       | index | PRIMARY       | PRIMARY | 159     | NULL | 442961 |    10.00 | Using where; Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
```

### ALL
테이블 풀 스캔 방식입니다. 활용할 인덱스가 없거나 인덱스 사용이 더 비효율적이라고 옵티마이저가 판단했을 때 선택됩니다.
ALL 일 때는 인덱스를 새로 추가하는 방식으로 튜닝할 수 있는데, 전체 테이블 중 10~20% 이상 분량의 데이터를 조회할 때는 ALL 이 더 유리할 수 있습니다.
```mysql
EXPLAIN 
SELECT * FROM 사원;

* 결과
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------+
|  1 | SIMPLE      | 사원  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299157 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

## possible_keys
옵티마이저가 쿼리를 최적화하고자 사용할 수 있는 인덱스 목록을 출력합니다. 실제 사용한 인덱스가 아닌, 사용할 수 있는 기본키와 인덱스 목록만 보여줍니다.

## key
옵티마이저가 쿼리를 최적화하고자 사용한 기본키 또는 인덱스 명을 의미합니다. 어느 인덱스로 검색했는지 확인할 수 있어서 비효율적인 인덱스 사용 혹은 인덱스를 사용하지 않은 경우에는 튜닝의 대상이 됩니다.
```mysql
EXPLAIN
SELECT 사원번호
FROM 직급
WHERE 직급명 = 'Manager';

* 결과
+----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows   | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+--------------------------+
|  1 | SIMPLE      | 직급  | NULL       | index | PRIMARY       | PRIMARY | 159     | NULL | 442961 |    10.00 | Using where; Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
```

위 쿼리는 기본키를 활용하여 데이터에 접근합니다.

```mysql
EXPLAIN
SELECT * FROM 사원;

* 결과
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------+
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------+
|  1 | SIMPLE      | 사원  | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299157 |   100.00 | NULL  |
+----+-------------+-------+------------+------+---------------+------+---------+------+--------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```
위 쿼리는 type 이 ALL, key 가 null 임을 보아 인덱스를 활용하지 않음을 알 수 있습니다.

## key_len
인덱스를 사용할 때는 인덱스 전체를 사용 혹은 일부 인덱스만 사용합니다. key_len 은 사용한 인덱스의 바이트 수를 의미하며, INT 는 4바이트, varchar 는 3바이트입니다.

직급 테이블은 사원번호, 직급명, 시작일자를 합하여 PK 로 사용합니다.
```mysql
show index from 직급;

* 결과
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| 직급  |          0 | PRIMARY  |            1 | 사원번호    | A         |      301768 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| 직급  |          0 | PRIMARY  |            2 | 직급명      | A         |      442605 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
| 직급  |          0 | PRIMARY  |            3 | 시작일자    | A         |      442961 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
3 rows in set (0.01 sec)
```

아래 쿼리에서 key 는 PRIMARY, key_len 은 159 바이트입니다.
```
EXPLAIN
SELECT 사원번호
FROM 직급
WHERE 직급명 = 'Manager';

* 결과
+----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows   | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+--------------------------+
|  1 | SIMPLE      | 직급  | NULL       | index | PRIMARY       | PRIMARY | 159     | NULL | 442961 |    10.00 | Using where; Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+--------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
```

사원번호는 INT 로 4바이트, 직급명은 varchar(50) 으로 (50+1) * 3 = 155 바이트로, WHERE 에서 직급명으로 사원번호를 조회하면 PK 에서 사원번호와 직급명만 사용함을 알 수 있습니다.

## ref
reference 의 약자로 테이블 조인을 수행할 때 어떤 조건으로 해당 테이블에 액세스되었는지를 알려줍니다.
```mysql
EXPLAIN
SELECT 사원.사원번호, 직급.직급명
FROM 사원, 직급
WHERE 사원.사원번호 = 직급.사원번호
AND 사원.사원번호 BETWEEN 10001 AND 10100;

* 길이
+----+-------------+-------+------------+-------+---------------+---------+---------+----------------------+------+----------+--------------------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref                  | rows | filtered | Extra                    |
+----+-------------+-------+------------+-------+---------------+---------+---------+----------------------+------+----------+--------------------------+
|  1 | SIMPLE      | 사원  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL                 |  100 |   100.00 | Using where; Using index |
|  1 | SIMPLE      | 직급  | NULL       | ref   | PRIMARY       | PRIMARY | 4       | tuning.사원.사원번호 |    1 |   100.00 | Using index              |
+----+-------------+-------+------------+-------+---------------+---------+---------+----------------------+------+----------+--------------------------+
2 rows in set, 1 warning (0.00 sec)
```
위 쿼리에서 드리븐 테이블은 직급 테이블이고 ref 를 통해 사원.사원번호로 데이터를 검색한다는 것을 확인할 수 있습니다. (사실 WHERE 절에서 짐작할 수 있습니다.)

## rows
쿼리를 수행할때 접근하는 데이터의 모든 행 수를 나타냅니다. 디스크에서 데이터를 읽고 메모리에서 처리해야 할 행 수를 예상하는 값이고, 수시로 변경되고 Mysql 통계정보를 활용하여 산출하므로 정확하지 않습니다.
쿼리의 최종 결과 건수와 비교해 rows 수가 크게 많으면 불필요한 데이터를 mysql 엔진까지 가져온 것이므로 튜닝의 대상이 될 수 있습니다.

## filtered
쿼리로 DB 엔진에 가져온 데이터 대상으로 필터 조건에 따라 어느 정도의 비율로 데이터를 제거했는지 알려줍니다. DB 엔진으로 100건을 가져와 WHERE 절로 10건으로 필터링 되면 10(%) 로 출력됩니다.

필터링 과정: 스토리지 엔진에 있는 테이블에서 Mysql 엔진으로 100건의 데이터를 가져오고 사용자에게 보여주기 전에 필터링하여 10건을 보여줍니다. 

## extra
쿼리를 어떻게 수행할 것인지에 관한 추가 정보를 보어줍니다.

### Using where
WHERE 절의 필터조건을 사용해 mysql 엔진으로 가져온 데이터를 추출합니다. filtered 에서 설명한 필터링 과정에서 10건으로 추려주는 곳을 의미합니다.

### Using temporary
데이터의 중간 결과를 저장하기 위해 임시 테이블을 생성하고 정렬 혹은 중복제거 등의 작업을 수행합니다. DISTINCT, GROUP BY, ORDER BY 의 경우에 해당됩니다.

임시 테이블을 메모리에 생성하거나 메모리 영역을 초과하여 디스크에 임시 테이블을 생성하면 성능 저하 원이이 됩니다. 튜닝 대상이 될 수 있습니다.

### Uisng index
물리적인 데이터 파일을 읽지 않고 인덱스만 읽어서 쿼리 요청사항을 처리하는 경우입니다. 
커버링 인덱스 (covering index) 방식이라 부르며, 인덱스로 구성된 열만 쿼리에서 사용할 경우에 이 방식을 사용합니다.
```mysql
SELECT 직급명
FROM 직급
WHERE 사원번호 = 100000;
```

직급 테이블은 사원번호, 직급명, 시작일자 순으로 기본키가 구성되어있는데, WHERE 에서는 사원번호, SELECT 에서는 직급명을 조회하여 기본키만 활용하므로 커버링 인덱스 방식으로 데이터에 접근합니다.

### Using filesort
정렬이 필요한 데이터를 메모리에 올리고 정렬작업을 수행합니다. 이미 정렬된 인덱스를 사용하면 추가 정렬작업이 필요없지만 인덱스를 사용하지 못할 경우에는 정렬을 위해 메모리 영역에 데이터를 올립니다.

filesort 는 추가 정렬 작업이 필요하므로 튜닝 대상이 될 수 있습니다. 

# 튜닝 판단
## select_type 판단기준
- 좋음: SIMPLE, PRIMARY, DERIVED
- 나쁨: DEPENDENT *, UNCACHEABLE *

## type 판단기준
- 좋음: system, const, eq_ref
- 나쁨: index, all (둘 다 풀스캔합니다)

## extra
- 좋음: Using index
- 나쁨: Using filesort, Using temporary

# 확장된 실행계획 수행
실행계획에서 추가정보를 더 확인할 수 있습니다.

## EXPLAIN FORMAT = TRADITIONAL
Default 로 traditional 입니다.
```mysql
EXPLAIN FORMAT = TRADITIONAL
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 100001 AND 200000;

* 결과
+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+
|  1 | SIMPLE      | 사원  | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL | 20080 |   100.00 | Using where |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+-------+----------+-------------+
1 row in set, 1 warning (0.01 sec)
```

## EXPLAIN FORMAT = TREE
트리 형태로 추가된 실행계획항목을 보여줍니다.
```mysql
EXPLAIN FORMAT = TREE
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 100001 AND 200000;

* 결과
+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| EXPLAIN                                                                                                                                                       |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
| -> Filter: (`사원`.`사원번호` between 100001 and 200000)  (cost=4036.17 rows=20080)                                                                           |
|   -> Index range scan on 사원 using PRIMARY  (cost=4036.17 rows=20080)                                                                                        |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
```

## EXPLAIN FORMAT = JSON
JSON 형태로 추가된 실행계획항목을 보여줍니다.
```mysql
EXPLAIN FORMAT = JSON
SELECT *
FROM 사원
WHERE 사원번호 BETWEEN 100001 AND 200000; 

+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| EXPLAIN



                                                                                                                                   |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| {
  "query_block": {
    "select_id": 1,
    "cost_info": {
      "query_cost": "4036.54"
    },
    "table": {
      "table_name": "사원",
      "access_type": "range",
      "possible_keys": [
        "PRIMARY"
      ],
      "key": "PRIMARY",
      "used_key_parts": [
        "사원번호"
      ],
      "key_length": "4",
      "rows_examined_per_scan": 20080,
      "rows_produced_per_join": 20080,
      "filtered": "100.00",
      "cost_info": {
        "read_cost": "2028.54",
        "eval_cost": "2008.00",
        "prefix_cost": "4036.54",
        "data_read_per_join": "1M"
      },
      "used_columns": [
        "사원번호",
        "생년월일",
        "이름",
        "성",
        "성별",
        "입사일자"
      ],
      "attached_condition": "(`tuning`.`사원`.`사원번호` between 100001 and 200000)"
    }
  }
} |
+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
```

## EXPLAIN ANALYZE
앞의 실행계획은 예측된 실행계획에 대한 정보이고, 얘는 실제 측정한 실행계획 정보를 보여줍니다. (수행된 소요시간, 비용으로 실측실행계획과 예측실행계획 모두 보여줍니다.)
```mysql
EXPLAIN ANALYZE 
SELECT * 
FROM 사원 
WHERE 사원번호 BETWEEN 100001 AND 200000; 

* 결과
+-------------------------------------------------------------------------------------------------------------------------------------+
| EXPLAIN                                                                                                                             |
+-------------------------------------------------------------------------------------------------------------------------------------+
| -> Filter: (`사원`.`사원번호` between 100001 and 200000)  (cost=4036.54 rows=20080) (actual time=0.082..8.311 rows=10025 loops=1)
    -> Index range scan on 사원 using PRIMARY  (cost=4036.54 rows=20080) (actual time=0.079..7.389 rows=10025 loops=1)                |
+-------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.01 sec)
```

# 프로파일링
슬로우쿼리 혹은 문제가 될만한 쿼리의 원인을 찾아줍니다.

먼저 프로파일링 설정값을 확인하여 ON 으로 활설화해줘야합니다. (Default: OFF)
```mysql
show variables like 'profiling%';

* 결과
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| profiling              | OFF   |
| profiling_history_size | 15    |
+------------------------+-------+
2 rows in set, 1 warning (0.00 sec)

set profiling = 'ON';
* 결과
Query OK, 0 rows affected (0.004 sec)
```

아래처럼 확인할 수 있습니다.
```
SELECT 사원번호
FROM 사원
WHERE 사원번호 = 100000;

* 결과
+----------+
| 사원번호 |
+----------+
|   100000 |
+----------+
1 row in set (0.00 sec)

show profiles;

* 결과
+----------+------------+---------------------------------------------------------+
| Query_ID | Duration   | Query	                                                  |
+----------+------------+---------------------------------------------------------+
|        1 | 0.00055779 | SELECT 사원번호 FROM 사원 WHERE 사원번호 = 100000       |
+----------+------------+---------------------------------------------------------+
1 rows in set (0.000 sec)
```
쿼리 ID 에 대해서 프로파일링된 상세 내용을 확인할 수 있습니다.
```mysql
show profile for query 1;

* 결과
+------------------------+----------+
| Status                 | Duration |
+------------------------+----------+
| Starting               | 0.000116 |
| checking permissions   | 0.000009 |
| Opening tables         | 0.000039 |
| After opening tables   | 0.000008 |
| System lock            | 0.000008 |
| table lock             | 0.000022 |
| init                   | 0.000037 |
| Optimizing             | 0.000029 |
| Statistics             | 0.000096 |
| Preparing              | 0.000006 |
| Unlocking tables       | 0.000020 |
| Preparing              | 0.000024 |
| Executing              | 0.000006 |
| Sending data           | 0.000020 |
| End of update loop     | 0.000013 |
| Query end              | 0.000005 |
| Commit                 | 0.000006 |
| closing tables         | 0.000004 |
| Unlocking tables       | 0.000003 |
| closing tables         | 0.000008 |
| Starting cleanup       | 0.000003 |
| Freeing items          | 0.000007 |
| Updating status        | 0.000064 |
| Reset for next command | 0.000006 |
+------------------------+----------+
24 rows in set (0.005 sec)
```

Duration 이 높으면 문제가 될 소지가 높은 구간입니다.

## 결과 해석
ALL, CPU 등 여러 정보를 선택하여 출력할 수 있습니다.

### all
```mysql
show profile all for query 1;

* 결과
+--------------------------------+----------+----------+------------+-------------------+---------------------+--------------+---------------+---------------+-------------------+-------------------+-------------------+-------+--------------------------------+----------------------+-------------+
| Status                         | Duration | CPU_user | CPU_system | Context_voluntary | Context_involuntary | Block_ops_in | Block_ops_out | Messages_sent | Messages_received | Page_faults_major | Page_faults_minor | Swaps | Source_function                | Source_file          | Source_line |
+--------------------------------+----------+----------+------------+-------------------+---------------------+--------------+---------------+---------------+-------------------+-------------------+-------------------+-------+--------------------------------+----------------------+-------------+
| starting                       | 0.000093 | 0.000000 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | NULL                           | NULL                 |        NULL |
| Executing hook on transaction  | 0.000003 | 0.000000 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | launch_hook_trans_begin        | rpl_handler.cc       |        1122 |
| starting                       | 0.000010 | 0.000000 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | launch_hook_trans_begin        | rpl_handler.cc       |        1124 |
| checking permissions           | 0.000007 | 0.000000 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | check_access                   | sql_authorization.cc |        2207 |
| Opening tables                 | 0.000052 | 0.000000 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | open_tables                    | sql_base.cc          |        5605 |
| init                           | 0.000011 | 0.015625 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | Sql_cmd_dml::execute           | sql_select.cc        |         684 |
| System lock                    | 0.000025 | 0.000000 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | mysql_lock_tables              | lock.cc              |         329 |
| optimizing                     | 0.000018 | 0.000000 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | JOIN::optimize                 | sql_optimizer.cc     |         282 |
| statistics                     | 0.000118 | 0.000000 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | JOIN::optimize                 | sql_optimizer.cc     |         504 |
| preparing                      | 0.000015 | 0.000000 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | JOIN::optimize                 | sql_optimizer.cc     |         588 |
| executing                      | 0.000013 | 0.000000 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | SELECT_LEX_UNIT::ExecuteIterat | sql_union.cc         |        1084 |
| end                            | 0.000003 | 0.000000 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | Sql_cmd_dml::execute           | sql_select.cc        |         737 |
| query end                      | 0.000002 | 0.000000 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | mysql_execute_command          | sql_parse.cc         |        4703 |
| waiting for handler commit     | 0.000009 | 0.000000 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | ha_commit_trans                | handler.cc           |        1589 |
| closing tables                 | 0.000008 | 0.000000 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | mysql_execute_command          | sql_parse.cc         |        4754 |
| freeing items                  | 0.000064 | 0.000000 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | mysql_parse                    | sql_parse.cc         |        5435 |
| cleaning up                    | 0.000018 | 0.000000 |   0.000000 |              NULL |                NULL |         NULL |          NULL |          NULL |              NULL |              NULL |              NULL |  NULL | dispatch_command               | sql_parse.cc         |        2217 |
+--------------------------------+----------+----------+------------+-------------------+---------------------+--------------+---------------+---------------+-------------------+-------------------+-------------------+-------+--------------------------------+----------------------+-------------+
17 rows in set, 1 warning (0.00 sec)
```

### cpu
점유한 CPU 양을 출력합니다.
```mysql
show profile cpu for query 1;
* 결과
+--------------------------------+----------+----------+------------+
| Status                         | Duration | CPU_user | CPU_system |
+--------------------------------+----------+----------+------------+
| starting                       | 0.000093 | 0.000000 |   0.000000 |
| Executing hook on transaction  | 0.000003 | 0.000000 |   0.000000 |
| starting                       | 0.000010 | 0.000000 |   0.000000 |
| checking permissions           | 0.000007 | 0.000000 |   0.000000 |
| Opening tables                 | 0.000052 | 0.000000 |   0.000000 |
| init                           | 0.000011 | 0.015625 |   0.000000 |
| System lock                    | 0.000025 | 0.000000 |   0.000000 |
| optimizing                     | 0.000018 | 0.000000 |   0.000000 |
| statistics                     | 0.000118 | 0.000000 |   0.000000 |
| preparing                      | 0.000015 | 0.000000 |   0.000000 |
| executing                      | 0.000013 | 0.000000 |   0.000000 |
| end                            | 0.000003 | 0.000000 |   0.000000 |
| query end                      | 0.000002 | 0.000000 |   0.000000 |
| waiting for handler commit     | 0.000009 | 0.000000 |   0.000000 |
| closing tables                 | 0.000008 | 0.000000 |   0.000000 |
| freeing items                  | 0.000064 | 0.000000 |   0.000000 |
| cleaning up                    | 0.000018 | 0.000000 |   0.000000 |
+--------------------------------+----------+----------+------------+
17 rows in set, 1 warning (0.00 sec)
```

### block io
데이터 접근 단위인 블록 수준의 입/출력에 관한 정보를 출력합니다.
```mysql
show profile block io for query 1;

* 결과
+--------------------------------+----------+--------------+---------------+
| Status                         | Duration | Block_ops_in | Block_ops_out |
+--------------------------------+----------+--------------+---------------+
| starting                       | 0.000093 |         NULL |          NULL |
| Executing hook on transaction  | 0.000003 |         NULL |          NULL |
| starting                       | 0.000010 |         NULL |          NULL |
| checking permissions           | 0.000007 |         NULL |          NULL |
| Opening tables                 | 0.000052 |         NULL |          NULL |
| init                           | 0.000011 |         NULL |          NULL |
| System lock                    | 0.000025 |         NULL |          NULL |
| optimizing                     | 0.000018 |         NULL |          NULL |
| statistics                     | 0.000118 |         NULL |          NULL |
| preparing                      | 0.000015 |         NULL |          NULL |
| executing                      | 0.000013 |         NULL |          NULL |
| end                            | 0.000003 |         NULL |          NULL |
| query end                      | 0.000002 |         NULL |          NULL |
| waiting for handler commit     | 0.000009 |         NULL |          NULL |
| closing tables                 | 0.000008 |         NULL |          NULL |
| freeing items                  | 0.000064 |         NULL |          NULL |
| cleaning up                    | 0.000018 |         NULL |          NULL |
+--------------------------------+----------+--------------+---------------+
17 rows in set, 1 warning (0.00 sec)
```